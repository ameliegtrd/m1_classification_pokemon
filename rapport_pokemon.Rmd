---
title: "Rapport du projet de classification des Pokémon"
author: "Elisa Floch, Amélie Goutard et Violette Marmion"
output:
  pdf_document: default
  fig_width: 2
  fig_height: 1
---
<style>body {text-align: justify}</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

```

# 1. Prise en main du jeu de données

Dans un premier temps, nous allons présenter la base de données ainsi que le sujet de notre étude de classification.

Le jeu de données concerne l’univers des Pokémon.
La franchise a été créée en 1996.
Elle est exploitee sous forme de jeux vidéos, mangas,   dessins animés, jeux de cartes ou jeux en réalité augmentée
Le principe du jeu repose sur la capture, le dressage et les combats de créatures “animales” imaginaires appelées Pokémon et possédant chacun leur caractéristiques propres.  

Le jeu de données proposé contient différentes informations et statistiques concernant chacun des Pokémon de la première à la huitèime génération (environ 890 individus).  

Les liens suivants ont été utiles pour la réalisation de notre projet :  
- Pokédia : [le *wikipedia des Pokémon*](https://www.pokepedia.fr/)   
- Pokédex : [la *base de données des Pokémon*](https://www.pokebip.com/pokedex)

La base de données initiale contenait 1045 lignes et 51 colonnes.
Une ligne correspond à un Pokémon identifié, uniquement, par son nom et par son numéro dans la base des données des Pokéemon, le Pokédex (non unique). 
Certains individus apparaissent plusieurs fois car ils ont plusieurs formes ou une évolution supplémentaire dite “méga”.
Nous avons décidé de conserver une unique forme pour chacun.
Les variables représentent les caractéristiques nominales telles que le nom (en anglais, en allemand et en japonais), le numéro d’identification, le statut (normal, légendaire, etc), la génération et l'espèce. 
Mais aussi le type de la créature.
Les Pokémon ont 1 ou 2 types parmi les 18 types existants : Grass, Fire, Water, Bug, Normal, Poison, Electric, Ground, Fairy, Fighting, Psychic, Rock, Ghost, Ice, Dragon, Dark, Steel et Flying. 

Des caractéristiques quantitaves sont aussi présentes.
Nous retrouvons la taille, le poids, les points de vie, d'attaque, de défense, de vitesse, etc.
Ensuite, il y a des caractéristiques de dressage, par exemple : le taux de capture.
Enfin, les dommages reçus contre un certain type.
Les valeurs des dommages sont égales à 0, 0.5, 1 ou 2.  


Dans un second temps, nous allons expliquer notre compréhension du jeu de données et montrer comment nous l'avons nettoyé.  

```{r libraries,  results='hide', include=FALSE}
### Librairies
# definition des librairies dont on a besoin
load_lib <- c("tidyverse", "kableExtra", "FactoMineR", "factoextra", "cowplot")
# packages necessaires qui ne sont pas installes
install_lib <- load_lib[!load_lib %in% installed.packages()] 
# installation des packages manquants
for (lib in install_lib) install.packages(lib,dependencies=TRUE) 
# chargement des packages
sapply(load_lib,require,character=TRUE)
```

```{r data, eval=TRUE, include=F, results='hide'}
### Importation des donnees et choix des colonnes
## on importe les donneess
pokemon <- read_delim(file="pokedex.csv", delim = ",", col_names = TRUE)
# resume statistique
summary(pokemon)
## on regarde s'il y a des donnees manquantes
# pour chaque colonne
pokemon %>% summarise_all(~ sum(is.na(.))) 
# au total
pokemon %>% map_df(~sum(is.na(.))) %>% rowSums() # 2448 
## on regarde le nombre de pokemon "doublons" (numero de pokedex)
sum(duplicated(pokemon[,"pokedex_number"])) # 147 doublons
## on enleve les doublons
pokemon2 <- pokemon %>% distinct(pokedex_number, .keep_all = TRUE) # on enleve les Mega et garde uniquement les formes de bases des pokemon (pas les evolutions)
## suppression de certaines colonnes
pokemon2 <- pokemon2 %>% select(-c("...1",german_name, japanese_name, species, catch_rate, base_friendship, base_experience, growth_rate, egg_type_number, egg_type_1, egg_type_2, egg_cycles, abilities_number, ability_1, ability_2, ability_hidden, total_points))
```

Après avoir importé les données, nous regardons s'il y a des données manquantes.
Par exemple, dans la colonne *type_2*, nous constatons qu'il y a 492 données manquantes.
Ce qui semble normal puisque tous les pokemons n'ont pas 2 types.
Autre exemple, la colonne *percentage_male* comporte 173 données manquantes.
Au total, nous obtenons 2448 données manquantes.  

Ensuite, nous avons regardé le nombre de Pokémon qui étaient en doublons, en fonction du numéro de Pokédex.
Nous avons obtenu 147 doublons que nous avons immédiatement supprimés.
Suite à cela, nous avons enlevé les individus ayant une évolution supplémentaire dite “méga”.
Notre base est désormais uniquement constituée des Pokémon ayant une forme classique (la forme de base).
Nous obtenons donc une base contenant 898 individus.  

Puis, nous avons décidé de supprimer des colonnes, selon nous, inutiles à notre analyse.
Telles que *german_name*, *japanese_name*, *catch_rate*, etc.
Nous avons donc conservé 34 colonnes.  

Ensuite, nous avons transformé la variable qualitative *status* en variable quantitative en lui attribuant les valeurs 1 pour Normal, 2 pour Sub Legendary, 3 pour Legendary et 4 pour Mythical.

```{r , results='hide', include=FALSE}
pokemon3 = pokemon2
## on transforme la variable qualitative status en quantitative
# on convertit en facteur
pokemon3$status <- as_factor(pokemon3$status)
class(pokemon3$status)
levels(pokemon3$status) # du moins rare au plus rare
# on recode : 1 pour Normal, 2 pour Sub Legendary, 3 pour Legendary et 4 pour Mythical
pokemon3$status <- as.numeric(pokemon3$status)
```

Enfin, nous avons fait une exploration des données à l'aide de quelques statistiques descriptives.  

Le tableau ci-dessous montre le nombre de Pokémon par génération :









```{r}
## Afficher le nombre de pokemons par generation
# on cree un tableau avec le nombre de pokemons par generation 
# nb_pokemon_gen <- pokemon2 %>% count(generation)  
# on affiche la table obtenue
knitr::kable(pokemon2 %>% count(generation) ) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

Nous remarquons que c'est la cinquième génération qui comporte le plus de Pokémon. 
Il y en a 156.  

Le graphique ci-dessous représente la variable *type_1* de Pokémon :

```{r, out.width="70%", fig.align="center"}
ggplot(pokemon2) + aes(x=reorder(type_1,type_1, function(x)-length(x)), fill=type_1) + geom_bar() + ggtitle("Représentation des types 1 de pokemons") +  xlab("Type 1") + ylab("Nombre de types") + theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


Le type *Water* est le plus repésenté puisque quasiment 125 créatures incarnent ce type.

# 2. Classification des individus
## 2.1. ACP

Avant de commencer la classification, nous allons réaliser une Analyse en Composantes Principales. L’analyse des données nous apporte une première interprétation et intuition. Nous souhaitons voir si les Pokémon se distinguent bien par leurs types.

Nous cherchons donc à représenter les individus, les Pokémon, et à voir graphiquement par une ACP si des groupes se forment, soit si certains individus ont des caractéristiques communes.  

Ensuite, nous chercherons à vérifier notre intuition par une classification. L’objectif de notre classification est de prédire le type d'un Pokémon grâce à ses autres caractéristiques.

Tout d'abord, nous nous focalisons sur les Pokémon ayant un seul type pour l'ACP. Nous standardisons les données car elles n'ont pas toutes la même unité.

```{r,out.width="70%", fig.align="center"}
### on garde uniquement les pokemon qui n'ont qu'un seul type
pokemon_type1 <- pokemon3 %>% 
  filter(type_number == 1) %>%
  select(-c(pokedex_number,type_2, type_number, percentage_male))
### on applique l'ACP
acp_pokemonType1 <- PCA(X = select(pokemon_type1,-name), scale.unit=TRUE, quali.sup=3, graph=FALSE)
# on a standardise les donnees avec scale.unit=TRUE
# on a indique la variable qualitative type_1 supplementaire 
### inertie
fviz_screeplot(acp_pokemonType1) 
# d'apres le graphique, on peut aller regarder jusqu'a 4 dimension
```

Nous représentons le diagramme en barre des pourcentages d’inertie de chaque axe et nous décidons de conserver 4 axes.


```{r, message=F, out.width="70%", fig.align="center"}
## dim 1 et 3
# les variables
var = fviz_pca_var(acp_pokemonType1, 
             axes= c(1,3),
             col.var = "contrib",
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"))
# les individus
ind = fviz_pca_ind (acp_pokemonType1,
              axes= c(1,3),
              geom.ind = "point", # juste les points, pas le texte
              habillage = 3, # pour la var supp
              addEllipses =TRUE, 
              # ellipse.type = "confidence", # ellipse de confiance
              repel = TRUE) # evite le chevauchement de texte
plot_grid(ind,var, ncol=2, nrow=1)
```

Nous remarquons que 3 groupes semblent se distinguer. Le premier groupe contient les Pokémon de type Fighting, le second groupe contient les Pokémon de types Psychic et Ghost et enfin le dernier regroupe tous les types restants.


Nous réalisons désormais l'ACP avec tous les Pokémons. Pour cela, on regroupe les colonnes *type_1* et *type_2"* dans la colonne *type*. Cette colonne recense alors 177 types. 

Nous calculons l'ACP et standardisons les données. Nous choisissons, dans ce cas aussi, de conserver 4 axes.
```{r , results='hide', include=FALSE}
### on regroupe les colonnes type_1 et type_2 en une intutule type
pokemon_type12 <- pokemon3 %>% 
  unite("type",type_1:type_2, na.rm=TRUE, remove=FALSE) %>% 
  select(-c(pokedex_number,type_1, type_2, type_number, percentage_male))
# nombre de type
pokemon_type12 %>% distinct(type) # 177
### on applique l'ACP
acp_pokemonType12 <- PCA(X = select(pokemon_type12,-name), scale.unit=TRUE, quali.sup=3, graph=FALSE)
# on a standardise les donnees avec scale.unit=TRUE
# on a indique la variable qualitative type_1 supplementaire 
### inertie
fviz_screeplot(acp_pokemonType12) 
# d'apres le graphique, on peut aller regarder jusqu'a 4 dimension
### on represente graphiquement
```


```{r, out.width="70%", fig.align="center", message=F, warning=F}
var <- plot(acp_pokemonType12,choix="var")
ind <- plot(acp_pokemonType12,choix="ind") # avec les individus supplementaires
plot_grid(ind,var, ncol=2, nrow=1)
```

Il est difficile de lire clairement les types étant donnée qu'il y en a 177 mais 4 voire 5 groupes semblent se distinguer. 

_Conclusion de l'ACP :_  on aurait tendance a préférer le regroupement de type_1 et type_2 car les groupes semblent plus distincts. Cependant, nous allons garder uniquement la colonne *type_1* afin de conserver une ligne par Pokémon. 

## 2.2. CAH

Le but est de créer une suite de partitions emboîtées : en n classes, puis en n-1 classes, etc jusqu’a obtenir une unique classe.
Nous allons donc choisir le nombre de groupes le plus pertinent à la fin (par comparaison des partitions créées).  

Les caractéristiques de la Classification Ascendante Hiérarchique sont :  
- **Ascendant** : on regroupe des individus/classes à chaque étape  
- **Hiérarchique** : les classes formées à chaque étape ne sont pas remises en cause  
Le principe de cette méthode est de partir de la classification la plus fine : chaque individu est dans sa propre classe.  

Pour appliquer cet algorithme, on voit qu’il nous faut :  
- Définir une distance ou dissimilarité entre individus  		
- Définir une distance entre classes : pour le recalcul des distances à l’issue de chaque étape  
On parle alors de stratégie d'agrégation  

Après avoir standardisé les données, nous pouvons définir la matrice de distances entre individus.
Nous avons calculer la distance de Ward.
Cette distance nécessite de disposer des distances euclidiennes (pour que la notion de barycentre comme centre du nuage de points ait un sens), c'est pourquoi nous les avons calculées au préalable.
Elle tend à créer des groupes sphériques et de tailles similaires.
Et elle est sensible à la présence de points outliers.
C'est le critère le plus utilisé.
À chaque étape, nous créons de nouvelles classes en agrégeant les classes (pouvant être réduites à un seul individu) les plus proches.
À posteriori, on choisit le nombre de groupes le plus adapté.
En regardant la  courbe d'inertie des 20 premières valeurs, nous hésitons entre 3, 5 et 6 groupes. 
Le choix n'étant pas très naturel, nous décidons de tester les 3 cas et ainsi de choisir ce qui nous semble le plus convenable.  

Commençons par faire une partition en 3 groupes.
Tout d’abord, nous avons créé les classes puis nous les avons représentées sur le dendrogramme suivant :


```{r,  results='hide', include=FALSE}
## on standardise les donnees
pokemon.sc = scale(select(pokemon_type12,-c(name,type)))
apply(pokemon.sc,2,mean)
apply(pokemon.sc,2,sd)
## distance euclidienne
d=dist(pokemon.sc)
## cah
cah.ward = hclust(d,method="ward.D")
plot(cah.ward,hang=-1)
## choix du nombre de groupe (courbe d'inertie des 20 premieres valeurs)
plot(rev(cah.ward$height)[1:20],type="b")
```


```{r,  results='hide', include=FALSE}
### partition en 3 groupes
pokemon_cah <- pokemon_type12
## creation des classes
K=3
gpe.ward = cutree(cah.ward,k=K)
gpe.ward
```


```{r}
## representation des classes sur le dendrogramme
plot(cah.ward,hang=-1)
rect.hclust(cah.ward, K, border ="blue")
```


Nous constatons que les classes 2 et 3 sont bien distinctes. 
La classe 1 est globalement indépendante mais un peu plus mélangée avec les deux autres classes.
D’après nos connaissances sur le sujet, les groupes ne sont pas mauvais mais nous pensons que nous pouvons faire mieux avec  un nombre de classes plus élevé.  

Ensuite, nous avons fait une représentation des groupes sur les axes factoriels.
Le graphique des individus confirme notre intuition : les classes 2 et 3 sont distinctes, la classe 1 l'est globalement mais se mélange aussi légèrement avec les autres classes.

Enfin, nous avons tester notre modèle pour différentes valeurs de K.  
- Pour 4 groupes : Nous retrouvons 2 classes distinctes (4 et 2)  et 2 classes plus mélangées (1 et 3).  
- Pour 5 groupes : Nous observons 2 classes distinctes (5 et 3) tandis que les autres classes sont moins évidentes. Si nous comparons les classes 2 et 4 à la classe 1, nous pouvons dire que cette dernière se distingue un peu plus de la classe 5.  
- Pour 6 groupes : Nous remarquons que les classes 3, 5 et 6 sont distinctes. Elles correspondent bien au graphique des variables (3 groupes de flèches allant dans 3 directions différentes).  

Ainsi, avec une CAH, nous décidons de conserver 3 classes. 
Ce choix n’a pas été très évident mais c’est celui qui nous semble le plus raisonnable. 
Regardons dans la partie suivante si notre choix se confirme avec les kmeans.  


## 2.3. Kmeans


## 2.4. Choix de la classification

Utilisation des algorithmes de classification vus en cours
- Notions de proximité pour certaines variables (variables Type ou variables against X)
- Réflexion sur les choix opérés  

Décider d’une classification finale 
- Nombre de groupes ?

# 3. Étude des groupes obtenus

Caractérisation de la partition obtenue 
Représentation informative des résultats
- Graphiques adaptés, représentations factorielles si adaptées

# 4. Conclusions, perspectives et critique

Quels points peuvent être critiqués dans vos choix ?
Quelles pistes pourraient être explorées pour aller plus loin et/ou mieux explorer ces données ?
```{r}
```
