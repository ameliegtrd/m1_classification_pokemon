---
title: "Rapport du projet de classification des Pokémon"
author: "Elisa Floch, Amélie Goutard et Violette Marmion"
output:
  pdf_document: default
---
<style>body {text-align: justify}</style>

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)

```

# 1. Prise en main du jeu de données

*TRAVAIL À FAIRE DANS CETTE PARTIE :*
Comprehension et nettoyage du jeu de donnees 
- Données manquantes ?  
- Choix des variables (regroupement ?) en vue d’une classification   
- Standardisation ?
*À FINIR*

Dans un premier temps, nous allons présenter la base de données ainsi que le sujet de notre étude de classification.

Le jeu de données concerne l’univers des Pokémon.
La franchise a été créée en 1996.
Elle est exploitee sous forme de jeux vidéos, mangas,   dessins animés, jeux de cartes ou jeux en réalité augmentée
Le principe du jeu repose sur la capture, le dressage et les combats de créatures “animales” imaginaires appelées Pokémon et possédant chacun leur caractéristiques propres.  

Le jeu de données proposé contient différentes informations et statistiques concernant chacun des pokemon de la première à la huitime génération (environ 890 individus).  

Les liens suivants ont été utiles pour la réalisation de notre projet :  
- Pokédia : [le wikipedia des Pokémon](https://www.pokepedia.fr/)    
- Pokédex : [la base de données des Pokémon](https://www.pokebip.com/pokedex)  

La base de données initiale contenait 1045 lignes et 51 colonnes.
Une ligne correspond à un Pokémon identifié, uniquement, par son nom et par son numéro dans la base des données des Pokéemon, le Pokédex (non unique). 
Certains individus apparaissent plusieurs fois car ils ont plusieurs formes ou une évolution supplémentaire dite “méga”.
Nous avons décidé de conserver une unique forme pour chacun.
Les variables représentent les caractéristiques nominales telles que le nom (en anglais, en allemand et en japonais), le numéro d’identification, le statut (normal, légendaire, etc), la génération et l'espèce. 
Mais aussi le type de la créature.
Les Pokémon ont 1 ou 2 types parmi les 18 types existants.
Les caractéristiques quantitaves sont aussi présentes.
Nous retrouvons la taille, le poids, les points de vie, d'attaque, de défense, de vitesse, etc.
Ensuite, il y a des caractéristiques de dressage, par exemple : le taux de capture.
Enfin, les dommages reçus contre un certain type.
Les valeurs des dommages sont égales à 0, 0.5, 1 ou 2.  


Dans un second temps, nous allons expliquer notre compréhension du jeu de données. Et montrer comment nous l'avons nettoyé.  

```{r libraries,  results='hide', include=FALSE}
### Librairies
# definition des librairies dont on a besoin
load_lib <- c("tidyverse", "kableExtra", "FactoMineR", "factoextra", "cowplot")
# packages necessaires qui ne sont pas installes
install_lib <- load_lib[!load_lib %in% installed.packages()] 
# installation des packages manquants
for (lib in install_lib) install.packages(lib,dependencies=TRUE) 
# chargement des packages
sapply(load_lib,require,character=TRUE)
```

```{r data, eval=TRUE, include=F, results='hide'}
### Importation des donnees et choix des colonnes
## on importe les donneess
pokemon <- read_delim(file="pokedex.csv", delim = ",", col_names = TRUE)
# resume statistique
summary(pokemon)
## on regarde s'il y a des donnees manquantes
# pour chaque colonne
pokemon %>% summarise_all(~ sum(is.na(.))) 
# au total
pokemon %>% map_df(~sum(is.na(.))) %>% rowSums() # 2448 
## on regarde le nombre de pokemon "doublons" (numero de pokedex)
sum(duplicated(pokemon[,"pokedex_number"])) # 147 doublons
## on enleve les doublons
pokemon2 <- pokemon %>% distinct(pokedex_number, .keep_all = TRUE) # on enleve les Mega et garde uniquement les formes de bases des pokemon (pas les evolutions)
## suppression de certaines colonnes
pokemon2 <- pokemon2 %>% select(-c("...1",german_name, japanese_name, species, catch_rate, base_friendship, base_experience, growth_rate, egg_type_number, egg_type_1, egg_type_2, egg_cycles, abilities_number, ability_1, ability_2, ability_hidden, total_points))
```

Après avoir importé les données, nous regardons s'il y a des données manquantes.
Par exemple, dans la colonne *type_2*, nous constatons qu'il y a 492 données manquantes.
Ce qui semble normal puisque tous les pokemons n'ont pas 2 types.
Autre exemple, la colonne *percentage_male* comporte 173 données manquantes.
Au total, nous obtenons 2448 données manquantes.  

Ensuite, nous avons regardé le nombre de Pokémon qui étaient en doublons, en fonction du numéro de Pokédex.
Nous avons obtenu 147 doublons que nous avons immédiatement supprimés.
Suite à cela, nous avons enlevé les individus ayant une évolution supplémentaire dite “méga”.
Notre base est désormais uniquement constituée des Pokémon ayant une forme classique (la forme de base).
Nous obtenons donc une base contenant 898 individus.  

Puis, nous avons décidé de supprimer des colonnes, selon nous, inutiles à notre analyse.
Telles que *german_name*, *japanese_name*, *catch_rate*, etc.
Nous avons donc conservé 34 colonnes.  

Enfin, nous avons fait une exploration des données à l'aide de quelques statistiques descriptives.  

Le tableau ci-dessous montre le nombre de Pokémon par génération :





```{r}
## Afficher le nombre de pokemons par generation
# on cree un tableau avec le nombre de pokemons par generation 
# nb_pokemon_gen <- pokemon2 %>% count(generation)  
# on affiche la table obtenue
knitr::kable(pokemon2 %>% count(generation) ) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))
```

Nous remarquons que c'est la cinquième génération qui comporte le plus de Pokémon. 
Il y en a 156.  

Le graphique ci-dessous représente la variable *type_1* de Pokémon :

```{r}
ggplot(pokemon2) + aes(x=reorder(type_1,type_1, function(x)-length(x)), fill=type_1) + geom_bar() + ggtitle("Représentation des types 1 de pokemons") +  xlab("Type 1") + ylab("Nombre de types") + theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


Le type *Water* est le plus repésenté puisque quasiment 125 créatures incarnent ce type.

# 2. Classification des individus
## 2.1. ACP



Avant de commencer la classification, nous allons réaliser une Analyse Factorielle Composantes Multiples. L’analyse des données nous apporte une première interprétation et intuition. Nous souhaitons voir si les Pokémon se distinguent bien par leurs types ou leurs caractéristiques.

Pour réaliser cette AFCM, nous sélectionnons les variables qualitatives du jeu de données : *status* , *type_1* et *type_2*. 


Nous représentons le diagramme en barre des pourcentages d’inertie de chaque axe et nous décidons de garder tous les axes pour ne pas perdre d’information pour la classification. Nous récupérons les scores des individus selon les axes.

Nous affichons maintenant la représentation barycentrique des axes. 


## 2.2. CAH

Le but est de créer une suite de partitions emboîtées : en n classes, puis en n − 1 classes, etc jusqu’`a obtenir une unique classe.
Nous allons donc choisir le nombre de groupes le plus pertinent à la fin (par comparaison des partitions créées).  

Les caractéristiques de la Classification ascendante hiérarchique sont :  
**- Ascendant :** on regroupe des individus/classes à chaque étape  
**- Hiérarchique :** les classes formées à chaque étape ne sont pas remises en cause  
Le principe de cette méthode est de partir de la classification la plus fine : chaque individu est dans sa propre classe.  

Pour appliquer cet algorithme, on voit qu’il nous faut :  
- Définir une distance ou dissimilarité entre individus  		
- Définir une distance entre classes : pour le recalcul des distances à l’issue de chaque étape  
On parle alors de stratégie d'agrégation  

Après avoir standardisé les données, nous pouvons définir la matrice de distances entre individus.
Nous avons calculer la distance de Ward.
Cette distance nécessite de disposer des distances euclidiennes (pour que la notion de barycentre comme centre du nuage de points ait un sens), c'est pourquoi nous les avons calculées au préalable.
Elle tend à créer des groupes sphériques et de tailles similaires.
Et elle est sensible à la présence de points outliers.
C'est le critère le plus utilisé.
À chaque étape, nous créons de nouvelles classes en agrégeant les classes (pouvant être réduites à un seul individu) les plus proches.
À posteriori, on choisit le nombre de groupes le plus adapté.
En regardant la  courbe d'inertie des 20 premières valeurs, nous hésitons entre 3, 5 et 6 groupes. 
Le choix n'étant pas très naturel, nous décidons de tester les 3 cas et ainsi de choisir ce qui nous semble le plus convenable.  

Commençons par faire une partition en 3 groupes.
Tout d’abord, nous avons créé les classes puis nous les avons représentées sur le dendrogramme suivant :  
```{r}
pokemon3 = pokemon2
### on regroupe les colonnes type_1 et type_2 en une intutule type
pokemon_type12 <- pokemon3 %>% 
  unite("type",type_1:type_2, na.rm=TRUE, remove=FALSE) %>% 
  select(-c(pokedex_number,type_1, type_2, type_number, percentage_male))

## on standardise les donnees
pokemon.sc = scale(select(pokemon_type12,-c(name,type)))
## distance euclidienne
d=dist(pokemon.sc)
## cah
cah.ward = hclust(d,method="ward.D")
plot(cah.ward,hang=-1)
```
Nous constatons que les classes 2 et 3 sont bien distinctes. 
La classe 1 est globalement indépendante mais un peu plus mélangée avec les deux autres classes.
D’après nos connaissances sur le sujet, les groupes ne sont pas mauvais mais nous pensons que nous pouvons faire mieux avec  un nombre de classes plus élevé.  

Ensuite, nous avons fait une représentation des groupes sur les axes factoriels.
Le graphique des individus confirme notre intuition : les classes 2 et 3 sont distinctes, la classe 1 l'est globalement mais se mélange aussi légèrement avec les autres classes.

Enfin, nous avons tester notre modèle pour différentes valeurs de K.  
- Pour 4 groupes : Nous retrouvons 2 classes distinctes (4 et 2)  et 2 classes plus mélangées (1 et 3).  
- Pour 5 groupes : Nous observons 2 classes distinctes (5 et 3) tandis que les autres classes sont moins évidentes. Si nous comparons les classes 2 et 4 à la classe 1, nous pouvons dire que cette dernière se distingue un peu plus de la classe 5.  
- Pour 6 groupes : Nous remarquons que les classes 3, 5 et 6 sont distinctes. Elles correspondent bien au graphique des variables (3 groupes de flèches allant dans 3 directions différentes).  

Ainsi, avec une CAH, nous décidons de conserver 3 classes. 
Ce choix n’a pas été très évident mais c’est celui qui nous semble le plus raisonnable. 
Regardons dans la partie suivante si notre choix se confirme avec les kmeans.  

## 2.3. Kmeans


## 2.4. Choix de la classification

Utilisation des algorithmes de classification vus en cours
- Notions de proximité pour certaines variables (variables Type ou variables against X)
- Réflexion sur les choix opérés  

Décider d’une classification finale 
- Nombre de groupes ?

# 3. Étude des groupes obtenus

Caractérisation de la partition obtenue 
Représentation informative des résultats
- Graphiques adaptés, représentations factorielles si adaptées

# 4. Conclusions, perspectives et critique

Quels points peuvent être critiqués dans vos choix ?
Quelles pistes pourraient être explorées pour aller plus loin et/ou mieux explorer ces données ?
```{r}
```
