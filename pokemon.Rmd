---
title: "Pokemon"
author: "FLOCH ELisa, GOUTARD Amélie et MARMION Violette"
date: '2022-04-01'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Librairies
```{r library, eval=TRUE, include=TRUE}
# definition des librairies dont on a besoin
load_lib <- c("tidyverse", "kableExtra", "FactoMineR")
# packages necessaires qui ne sont pas installes
install_lib <- load_lib[!load_lib %in% installed.packages()] 
# installation des packages manquants
for (lib in install_lib) install.packages(lib,dependencies=TRUE) 
# chargement des packages
sapply(load_lib,require,character=TRUE)
```

## Importation des donnéees et choix des colonnes
```{r data, eval=TRUE, include=TRUE}
pokemon <- read_delim(file="pokedex.csv", delim = ",", col_names = TRUE)
summary(pokemon)

# on regarde s'il y a des donnees manquantes
pokemon %>% summarise_all(~ sum(is.na(.))) #%>% View # pour chaque colonne
# 492 pour colonne type_2 : normal, tous les pokemons n'ont pas 2 types
# 1 pour colonne weight_kg : pokemon 1033 Eternatus Eternamax
# 3 pour colonne ability_1 : ok
# 529 pour colonne ability_2 : ok
# 232 pour colonne ability_hidden : ok
# 18 pour colonne catch_rate
# 115 pour colonne base_friendship
# 120 pour colonne base_experience
# 1 pour colonne growth_rate
# 3 pour colonne egg_type_1
# 760 pour colonne egg_type_2
# 173 pour colonne percentage_male
# 1 pour colonne egg_cycles
pokemon %>% map_df(~sum(is.na(.))) %>% rowSums() # 2448 au total

# on regarde le nombre de pokemon "doublons" (numero de pokedex)
sum(duplicated(pokemon[,"pokedex_number"])) # 147 doublons
# on enleve les doublons
pokemon2 <- pokemon %>% distinct(pokedex_number, .keep_all = TRUE) # on enleve les Mega et garde uniquement les formes de bases des pokemon (pas les evolutions)

# suppression de certaines colonnes
pokemon2 <- pokemon2 %>% select(-c("...1",german_name, japanese_name, species, catch_rate, base_friendship, base_experience, growth_rate, egg_type_number, egg_type_1, egg_type_2, egg_cycles, abilities_number, ability_1, ability_2, ability_hidden, total_points ))

```
Notes de gael (pro de pokémon) : 
- pokémon acier en général bcp de défense
- pokémon psy ou/et insecte en général pas bcp d'hp et de défense
- pokémon psy bcp d'attaques spéciales
- pokémon combat grosse point d'attaque
- évolution plus forte au niveau de toutes les stats
- pokémon légers sont plus rapides 
- pokémon lourd moins rapodes mais en général des tanks (plus d'hp)
- les stats sont tjr équilibrée (à part légendaires) : si bcp d'hp alors moins d'attaque etc
- certains double type vont avoir parfois des stats plus faible mais ils ne sont pas forcément moins fort, ils peuvent bénificier de plus de résistance
- dragon fortes attaques (trop fort !!)
- en general les pokemons qui ont le plus de doubles faiblesses (colonnes against) vont etre equilibres et avoir pt des meilleurs stats
- pokemon fee plutot femelle
- pokemon roche combat male

## Exploration des données
```{r}
## Afficher le nombre de pokemons par generation
# on cree un tableau avec le nombre de pokemons par generation 
# nb_pokemon_gen <- pokemon2 %>% count(generation)  
# on affiche la table obtenue
knitr::kable(pokemon2 %>% count(generation) ) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

## Afficher le nombre de pokemons par status
# on cree un tableau avec le nombre de pokemons par generation 
# nb_pokemon_status <- pokemon2 %>% count(status)  
# on affiche la table obtenue
knitr::kable(pokemon2 %>% count(status) ) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

## Reprentation des types(1) de pokemons
# pour chaque type_1, on compte le nombre de fois qu'il apparait dans la bdd
# pokemon_type_1 <- pokemon2 %>% count(type_1) %>% arrange(desc(n))
# representation graphique des genres dans le top
ggplot(pokemon2) + aes(x=reorder(type_1,type_1, function(x)-length(x)), fill=type_1) + geom_bar() + ggtitle("Représentation des types 1 de pokemons") +  xlab("Type 1") + ylab("Nombre de types") + theme(axis.text.x = element_text(angle = 45, hjust = 1))

## Reprentation des types(2) de pokemons
# pour chaque type_2, on compte le nombre de fois qu'il apparait dans la bdd
# pokemon_type_2 <- pokemon2 %>% count(type_2) %>% arrange(desc(n))
# representation graphique des genres dans le top
ggplot(pokemon2) + aes(x=reorder(type_2,type_2, function(x)-length(x)), fill=type_2) + geom_bar() + ggtitle("Représentation des types 2 de pokemons") +  xlab("Type 2") + ylab("Nombre de types") + theme(axis.text.x = element_text(angle = 45, hjust = 1))
# on peut voir que 492 pokemons n'ont pas second type

## Boxplot de la taille des pokemons
ggplot(pokemon2) + aes(x = "", y=height_m, color=height_m) + geom_boxplot(fill="pink") + ggtitle("Boxplot de la taille des pokemon") +  xlab("") + ylab("Taille en mètre")

## Boxplot du poids des pokemons
ggplot(pokemon2) + aes(x = "", y=weight_kg) + geom_boxplot(fill="pink") + ggtitle("Boxplot du poids des pokemon") +  xlab("") + ylab("Poids en kg")
```
Différentes conclusions en fonction des générations ? Est-ce que la génération 8 a de meilleurs stats que la génération 1 ? plus de hp ?


## Analyse Factorielle

Avant de procéder à l'analyse factorielle, il faut transformer les variables qualitatives.
```{r}
pokemon3 = pokemon2
## pour le status
# on convertit en facteur
pokemon3$status <- as_factor(pokemon3$status)
class(pokemon3$status)
levels(pokemon3$status) # du moins rare au plus rare
# on recode : 1 pour Normal, 2 pour Sub Legendary, 3 pour Legendary et 4 pour Mythical
# pokemon3$status <- as.numeric(pokemon3$status)

# ## pour type_1
# # on convertit en facteur
# pokemon3$type_1 <- as_factor(pokemon3$type_1)
# class(pokemon3$type_1)
# levels(pokemon3$type_1) 
# pokemon3$type_1 <- fct_relevel(pokemon3$type_1, sort)
# levels(pokemon3$type_1) 
# pokemon3$type_1 <-as.numeric(pokemon3$type_1)
# 
# ## pour type_2
# # on convertit en facteur
# pokemon3$type_2 <- as_factor(pokemon3$type_2)
# class(pokemon3$type_2)
# levels(pokemon3$type_2) 
# pokemon3$type_2 <- fct_relevel(pokemon3$type_2,sort)
# pokemon3$type_2 <- as.numeric(pokemon3$type_2)

# Renommer les NA
pokemon3$type_2  <- fct_explicit_na(pokemon3$type_2 , "Aucun")

## on fait une AFCM sur les var qualitatives
poke_quali <- pokemon3 %>% select(status,type_1, type_2)
## analyse des correspondances sur tableau lexical
pokemon_afcm <- MCA(poke_quali)
# representation des inerties
library("factoextra")
fviz_screeplot(pokemon_afcm)

# representation des colonnes dans le plan
library("explor")
res <- explor::prepare_results(pokemon_afcm)
# on garde les scores des pokemon selon les axes
score_ind <- res$ind$Coord
# 

```
On a changé les valeurs pour les types de sorte que :
1 = "Bug"   
2 = "Dark"     
3 = "Dragon"   
4 = "Electric" 
5 = "Fairy"    
6 = "Fighting" 
7 = "Fire"     
8 = "Flying"  
9 = "Ghost"    
10 = "Grass"    
11 = "Ground"   
12 = "Ice"      
13 = "Normal"   
14 = "Poison"   
15 = "Psychic"  
16 = "Rock"    
17 = "Steel"    
18 = "Water"

```{r}
## on teste les differents algorithmes vus en cours
sum(duplicated(pokemon3$name)) # unicite des noms des pokemons
pokemon3 <- column_to_rownames(pokemon3, var="name")
# on standardise car les variables n'ont pas toutes la meme unite
FAMD(pokemon3 %>% select(-c(1)))

## choix de la classification finale (nb de groupes)


```
AFCM
```{r}
#on cree la base de donnees avec uniquement les variables qualitatives pour l'AFCM
pokemon_quali <- pokemon2 %>% select(status,type_1,type_2)

#calcul de l'AFCM
afcm_pok <- MCA(pokemon_quali)

#choix du nombre d'axe
barplot(afcm_pok$eig[,2]) #on garde tous les axes

#representation des variables
plot(afcm_pok, choix="var")

#representation barycentrique
plotellipses(afcm_pok)

# representation des individus
plot(afcm_pok, choix = "ind", invisible="ind")


```

## Classification
```{r}
## avec uniquement variable quantitatives
pokemon.sc = scale(pokemon3 %>% select(-c(name,pokedex_number,status,type_1, type_2)))
apply(pokemon.sc,2,mean)
apply(pokemon.sc,2,sd)

d=dist(pokemon.sc)

cah.ward = hclust(d,method="ward.D")
plot(cah.ward,hang=-1)

plot(rev(cah.ward$height)[1:20],type="b")

# on choisit 5 groupes
gpe.ward = cutree(cah.ward,k=5)
sort(gpe.ward)

dend = as.dendrogram(cah.ward)
library(dendextend)
dend %>% set("branches_k_color", k = 5) %>% set("labels_color",k=5) %>% set("labels_cex",0.8) %>% plot
# Pour interpréter chacun des groupes, on peut commencer par calculer quelques statistiques descriptives sur ces derniers (moyennes par groupes, rapport de corrélation...)
```
On veut regrouper les pokemons. Combien de groupes ?  
Le but est que si on rajoute de nouveaux pokemons à notre bdd il aille dans le bon groupe. 

```{r}
pok = as.data.frame(pokemon.sc)
pok$groupe = as.factor(gpe.ward)
par(mfrow=c(1,2))
acp = PCA(pok,scale.unit=TRUE,graph=F,quali.sup=30)
plot(acp,choix="var")
plot(acp,choix="ind",habillage = 10,col.hab=c("green","blue","red","orange","magenta"),autoLab="no")
```


```{r}
par(mfrow=c(1,1))

pokacp = pokemon3 %>%
  select(-c(status,type_1, type_2, percentage_male))

pokacp %>% summarise_all(~ sum(is.na(.)))%>% View #il y a 122 NA dans percentage_male
#J'AI FAIT L'ANALYSE SANS LA COLONNE PERCENTAGE_MALE LE TEMPS DE VOIR CE QU'ON EN FAIT

pokacp = as.data.frame(scale(pokacp))
acp = princomp(pokacp,cor=T,scores=T)
biplot(acp)


plot(acp$scores[,1],acp$scores[,2],type="n",xlim=c(-5,5),ylim=c(-5,5))
text(acp$scores[,1],acp$scores[,2],col=gpe.ward,cex=0.65,labels=rownames(pokacp))
abline(h=0,lwd=0.5,lty=2);abline(v=0,lwd=0.5,lty=2)
```

### Test avec les kmeans

packages utiles 
```{r}
library(cluster)
library(FactoMineR)
library(dendextend)
library(ggplot2)
library(NbClust)
library(ade4)
```

Choix du nombre de groupes 
```{r}
varintra = sapply(1:15,FUN=function(k){ kmeans(pokemon.sc,k,nstart=50)$tot.withinss })
plot(varintra,type="b")
```
On peut essayer de s'aider à l'aide d'indices automatiques
```{r}
NbClust(pokemon.sc,min.nc = 2,max.nc = 10,method="kmeans",index="all")
```
Partons sur 2 groupes et explorons la partition proposée

```{r}
K=2
cl = kmeans(fromage,K,nstart=50)
cl
gpe = cl$cluster
```
Représentation des groupes sur le premier plan factoriel

"Comparaison" des résulats de CAH et de Kmeans

```{r}
d=dist(pokemon.sc)
cah.ward = hclust(d,method="ward.D")
gpe.ward = cutree(cah.ward,k=2)
```

```{r}
par(mfrow=c(1,2))
CCpca = dudi.pca(pokemon.sc,scannf=FALSE,nf=2)

scatter(CCpca,posieig = "none",clab.row=0,clab.col = 0.8,pch=NA)
text(CCpca$li[,1], CCpca$li[,2],pos=1,labels =row.names(pokemon3),col=gpe+1,xpd=TRUE,cex=0.7)
#s.class(CCpca$li, factor(gpe), col = 2:4, add.plot = TRUE,clabel = 1)

scatter(CCpca,posieig = "none",clab.row=0,clab.col = 0.8,pch=NA)
text(CCpca$li[,1], CCpca$li[,2],pos=1,labels =row.names(pokemon3),col=gpe.ward+1,xpd=TRUE,cex=0.7)
#s.class(CCpca$li, factor(gpe.ward), col = 2:5, add.plot = TRUE,clabel = 1)
```

## Etude des groupes obtenus
```{r}

```
Les groupes doivent être cohérents (on peut s'aider des connaissances de mon frère voir si nos groupes semblent correspondre ou non)


## Conclusion
Etre critique : tester plusieurs modeles en prenant en compte differentes variables voir si on a de meilleures conclusions
Expliquer en quoi nos choix sont variables, et comment on aurait pu aller plus loin (peut être étudier plus certaines variables ect)
