---
title: "Pokemon"
author: "FLOCH ELisa, GOUTARD Amélie et MARMION Violette"
date: '2022-04-01'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Librairies
```{r library, eval=TRUE, include=TRUE}
# definition des librairies dont on a besoin
load_lib <- c("tidyverse", "kableExtra", "FactoMineR")
# packages necessaires qui ne sont pas installes
install_lib <- load_lib[!load_lib %in% installed.packages()] 
# installation des packages manquants
for (lib in install_lib) install.packages(lib,dependencies=TRUE) 
# chargement des packages
sapply(load_lib,require,character=TRUE)
```

## Importation des donnéees et choix des colonnes
```{r data, eval=TRUE, include=TRUE}
pokemon <- read_delim(file="pokedex.csv", delim = ",", col_names = TRUE)
summary(pokemon)

# on regarde s'il y a des donnees manquantes
pokemon %>% summarise_all(~ sum(is.na(.))) %>% View # pour chaque colonne
# 492 pour colonne type_2 : normal, tous les pokemons n'ont pas 2 types
# 1 pour colonne weight_kg : pokemon 1033 Eternatus Eternamax
# 3 pour colonne ability_1 : ok
# 529 pour colonne ability_2 : ok
# 232 pour colonne ability_hidden : ok
# 18 pour colonne catch_rate
# 115 pour colonne base_friendship
# 120 pour colonne base_experience
# 1 pour colonne growth_rate
# 3 pour colonne egg_type_1
# 760 pour colonne egg_type_2
# 173 pour colonne percentage_male
# 1 pour colonne egg_cycles
pokemon %>% map_df(~sum(is.na(.))) %>% rowSums() # 2448 au total

# on regarde le nombre de pokemon "doublons" (numero de pokedex)
sum(duplicated(pokemon[,"pokedex_number"])) # 147 doublons
# on enleve les doublons
pokemon2 <- pokemon %>% distinct(pokedex_number, .keep_all = TRUE) # on enleve les Mega et garde uniquement les formes de bases des pokemon (pas les evolutions)

# suppression de certaines colonnes
pokemon2 <- pokemon2 %>% select(-c("...1",german_name, japanese_name, species, catch_rate, base_friendship, base_experience, growth_rate, egg_type_number, egg_type_1, egg_type_2, egg_cycles, abilities_number, ability_1, ability_2, ability_hidden, total_points ))

```
Notes de gael (pro de pokémon) : 
- pokémon acier en général bcp de défense
- pokémon psy ou/et insecte en général pas bcp d'hp et de défense
- pokémon psy bcp d'attaques spéciales
- pokémon combat grosse point d'attaque
- évolution plus forte au niveau de toutes les stats
- pokémon légers sont plus rapides 
- pokémon lourd moins rapodes mais en général des tanks (plus d'hp)
- les stats sont tjr équilibrée (à part légendaires) : si bcp d'hp alors moins d'attaque etc
- certains double type vont avoir parfois des stats plus faible mais ils ne sont pas forcément moins fort, ils peuvent bénificier de plus de résistance
- dragon fortes attaques (trop fort !!)
- en general les pokemons qui ont le plus de doubles faiblesses (colonnes against) vont etre equilibres et avoir pt des meilleurs stats
- pokemon fee plutot femelle
- pokemon roche combat male

## Exploration des données
```{r}
## Afficher le nombre de pokemons par generation
# on cree un tableau avec le nombre de pokemons par generation 
# nb_pokemon_gen <- pokemon2 %>% count(generation)  
# on affiche la table obtenue
knitr::kable(pokemon2 %>% count(generation) ) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

## Afficher le nombre de pokemons par status
# on cree un tableau avec le nombre de pokemons par generation 
# nb_pokemon_status <- pokemon2 %>% count(status)  
# on affiche la table obtenue
knitr::kable(pokemon2 %>% count(status) ) %>% kable_styling(bootstrap_options = c("striped", "hover", "condensed"))

## Reprentation des types(1) de pokemons
# pour chaque type_1, on compte le nombre de fois qu'il apparait dans la bdd
# pokemon_type_1 <- pokemon2 %>% count(type_1) %>% arrange(desc(n))
# representation graphique des genres dans le top
ggplot(pokemon2) + aes(x=reorder(type_1,type_1, function(x)-length(x)), fill=type_1) + geom_bar() + ggtitle("Représentation des types 1 de pokemons") +  xlab("Type 1") + ylab("Nombre de types") + theme(axis.text.x = element_text(angle = 45, hjust = 1))

## Reprentation des types(2) de pokemons
# pour chaque type_2, on compte le nombre de fois qu'il apparait dans la bdd
# pokemon_type_2 <- pokemon2 %>% count(type_2) %>% arrange(desc(n))
# representation graphique des genres dans le top
ggplot(pokemon2) + aes(x=reorder(type_2,type_2, function(x)-length(x)), fill=type_2) + geom_bar() + ggtitle("Représentation des types 2 de pokemons") +  xlab("Type 2") + ylab("Nombre de types") + theme(axis.text.x = element_text(angle = 45, hjust = 1))
# on peut voir que 492 pokemons n'ont pas second type

## Boxplot de la taille des pokemons
ggplot(pokemon2) + aes(x = "", y=height_m, color=height_m) + geom_boxplot(fill="pink") + ggtitle("Boxplot de la taille des pokemon") +  xlab("") + ylab("Taille en mètre")

## Boxplot du poids des pokemons
ggplot(pokemon2) + aes(x = "", y=weight_kg) + geom_boxplot(fill="pink") + ggtitle("Boxplot du poids des pokemon") +  xlab("") + ylab("Poids en kg")
```
Différentes conclusions en fonction des générations ? Est-ce que la génération 8 a de meilleurs stats que la génération 1 ? plus de hp ?


## Analyse Factorielle

Avant de procéder à l'analyse factorielle, il faut transformer les variables qualitatives.
```{r}
pokemon3 = pokemon2
## pour le status
# on convertit en facteur
pokemon3$status <- as_factor(pokemon3$status)
class(pokemon3$status)
levels(pokemon3$status) # du moins rare au plus rare
# on recode : 1 pour Normal, 2 pour Sub Legendary, 3 pour Legendary et 4 pour Mythical
pokemon3$status <- as.numeric(pokemon3$status)

# ## pour type_1
# # on convertit en facteur
# pokemon3$type_1 <- as_factor(pokemon3$type_1)
# class(pokemon3$type_1)
# levels(pokemon3$type_1) 
# pokemon3$type_1 <- fct_relevel(pokemon3$type_1, sort)
# levels(pokemon3$type_1) 
# pokemon3$type_1 <-as.numeric(pokemon3$type_1)
# 
# ## pour type_2
# # on convertit en facteur
# pokemon3$type_2 <- as_factor(pokemon3$type_2)
# class(pokemon3$type_2)
# levels(pokemon3$type_2) 
# pokemon3$type_2 <- fct_relevel(pokemon3$type_2,sort)
# pokemon3$type_2 <- as.numeric(pokemon3$type_2)

##
pokemon3 <- pokemon3 %>% select(-c(pokedex_numbers))

```
On a changé les valeurs pour les types de sorte que :
1 = "Bug"   
2 = "Dark"     
3 = "Dragon"   
4 = "Electric" 
5 = "Fairy"    
6 = "Fighting" 
7 = "Fire"     
8 = "Flying"  
9 = "Ghost"    
10 = "Grass"    
11 = "Ground"   
12 = "Ice"      
13 = "Normal"   
14 = "Poison"   
15 = "Psychic"  
16 = "Rock"    
17 = "Steel"    
18 = "Water"

```{r}
## on teste les differents algorithmes vus en cours
sum(duplicated(pokemon3$name)) # unicite des noms des pokemons
pokemon3 <- column_to_rownames(pokemon3, var="name")
# on standardise car les variables n'ont pas toutes la meme unite
FAMD(pokemon3 %>% select(-c(1)))

## choix de la classification finale (nb de groupes)


```

AFCM
```{r}
library(FactoMineR)
pokemon_quali <- pokemon2 %>% select(c("name","status","type_1","type_2",))
```


## Classification
```{r}

```
On veut regrouper les pokemons. Combien de groupes ? 
Le but est que si on rajoute de nouveaux pokemons à notre bdd il aille dans le bon groupe. 

## Etude des groupes obtenus
```{r}

```
Les groupes doivent être cohérents (on peut s'aider des connaissances de mon frère voir si nos groupes semblent correspondre ou non)


## Conclusion
Etre critique : tester plusieurs modeles en prenant en compte differentes variables voir si on a de meilleures conclusions
Expliquer en quoi nos choix sont variables, et comment on aurait pu aller plus loin (peut être étudier plus certaines variables ect)
